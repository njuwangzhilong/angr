# Extract constraint & Re-run binary
&nbsp;&nbsp;&nbsp;&nbsp;Given a trace file recording entry of each block.
We force angr to follow the traced path and extract constraints whenever updated.
## Extract constraint
  ```python   
  from __future__ import print_function

import struct

import angr
import logging
import logging
import pickle
from angr.globals import varcontainer
logging.getLogger('angr').setLevel('DEBUG')



print(angr.__file__)
'''
this function read the trace generated by pin
'''
def load_trace():
	res = []
	with open("./demo1.out") as f:
		for line in f:
			if line.startswith('[B_ENT]'):
				addr = int(line[7:7+6], 16)
				res.append(addr)
			elif line.startswith('[C2LIB]') :
				addr = int(0)
				res.append(addr)

	return res
def main():
	#init global vars
	varcontainer._init()
	varcontainer.set_value("runcount",0) #the global flag "runcount" is used in simuvex/s_format.py, value zero means it's the first run. value one means it's re-run. 
	print(varcontainer.get_value('runcount'))
	# read in base block trace
	trace_log = load_trace()
	'''print trace
	for i in range(len(trace_log)):
		print("%x" % trace_log[i])

	'''
	print("*************first run the binary and get constraints*************")
	#load binary	
	proj = angr.Project('demo1', load_options={'auto_load_libs': False})
	main = proj.loader.main_bin.get_symbol("main")
	#set entry point 
	state = proj.factory.blank_state(addr=main.addr)
	state.stack_push(0x0)
	p = proj.factory.path(state)
	print("start entry:0x%x" % proj.entry)
	print("main entry:0x%x" % main.addr)
	#print("0x%x" % p.addr)
	#match the binary entry with PIN's base block trace
	if p.addr != trace_log[0] :
		print("ERROR: Entrance is not matching, exit")
		exit
	#symbolic execte the path
	for i in range(1,len(trace_log)):
		pg=p.step() 		#execute one step(one baseblock),and get pathgroup 	
		print(len(pg[0].state.se.constraints))
		sg=p.successors 	#get the state group
		ins_addr=trace_log[i] 	#read one of PIN's trace 
		sucs_num=len(sg)      	#get the lenth of state group
		print("The path has", sucs_num, "successors!")
		print(pg)             	#print the path group
		if ins_addr == 0 :	#skip the lib function
			p=pg[0]		
			pg=p.step()
			
			p=pg[0]	
			print(len(p.state.se.constraints))
			continue
		else:			#choose and step into the match path
			for j in range(sucs_num):
				sucs_entry=sg[j].addr
				if sucs_entry == ins_addr :
					print("success entry[%d]:%x" % (1,sucs_entry))
					p=pg[j]	
					
					break
	#p=p.step()[0]

	#print path
	for step in p.trace:
		print(step)
	print('There are %d constraints.' % len(p.state.se.constraints))
	print("input numbers:%d" % len(p.state.posix.dumps(0)))
	print(p.state.posix.dumps(0))
	#print(p.state.se.constraints[8])


	# save constraints objects
	filename= 'constraint.out'
	with open(filename, 'w') as f:                              # open file with write-mode
	    picklestring = pickle.dump(p.state.se.constraints, f)   # serialize and save object


if __name__ == "__main__":
	main()

  ```
### Results
<img src="https://github.com/njuwangzhilong/angr/blob/master/CodeExamples/photo/firstrun.PNG" width = "500" height = "100" alt="first run" />
## Re-run binary
  ```python 
  from __future__ import print_function

import struct

import angr
import logging
import logging
import pickle
from angr.globals import varcontainer
logging.getLogger('angr').setLevel('DEBUG')

def main():
	#init global vars
	varcontainer._init()
	varcontainer.set_value("runcount",1)
	print(varcontainer.get_value('runcount'))

	# read constraints objects
	filename= 'constraint.out'
	with open(filename, 'r') as f:
		constraints = pickle.load(f)   # read constraints file and build constraints object


		'''
		for constraint in p.state.se.constraints:
			print(constraint)
		'''

		
		#re-run  
		print("***********************re-run the binary**************************")
		varcontainer.set_value("constraints",constraints) 
		varcontainer.set_value("runcount",1)
		#load binary	
		proj = angr.Project('demo1', load_options={'auto_load_libs': False})
		main = proj.loader.main_bin.get_symbol("main")
		#set entry point 
		state = proj.factory.blank_state(addr=main.addr)
		state.stack_push(0x00)
		p = proj.factory.path(state)
		print("start entry:0x%x" % proj.entry)
		print("main entry:0x%x" % main.addr)
		#symbolic execte the path
		while(True):
			
			pg=p.step() 		#execute one step(one baseblock),and get pathgroup 	
			print(len(pg[0].state.se.constraints))
			sg=p.successors 	#get the state group
			sucs_num=len(sg)      	#get the lenth of state group
			print("The path has", sucs_num, "successors!")
			print(pg)             	#print the path group
			if sg[0].addr==0x00 :
				break;
			for j in range(sucs_num):
				sucs_entry=sg[j].addr
				print("success entry[%d]:%x" % (1,sucs_entry))
				p=pg[j]	
				break

		#print the execute trace
		for step in p.trace:
			print(step)
		print('There are %d constraints.' % len(p.state.se.constraints))
		print("input numbers:%d" % len(p.state.posix.dumps(0)))
		print(p.state.posix.dumps(0))

if __name__ == "__main__":
	main()
  ```
### Results
<img src="https://github.com/njuwangzhilong/angr/blob/master/CodeExamples/photo/rerun.PNG" width = "500" height = "100" alt="first run" />