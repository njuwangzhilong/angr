# Extract constraint & Re-run binary
&nbsp;&nbsp;&nbsp;&nbsp;Given a trace file recording entry of each block.
We force angr to follow the traced path and extract constraints whenever updated.
## 1.Extract constraint
  ```python   
  from __future__ import print_function

import struct

import angr
import logging
import logging
import pickle
from angr.globals import varcontainer
logging.getLogger('angr').setLevel('DEBUG')



print(angr.__file__)
'''
this function read the trace generated by pin
'''
def load_trace():
	res = []
	with open("./demo1.out") as f:
		for line in f:
			if line.startswith('[B_ENT]'):
				addr = int(line[7:7+6], 16)
				res.append(addr)
			elif line.startswith('[C2LIB]') :
				addr = int(0)
				res.append(addr)

	return res
def main():
	#init global vars
	varcontainer._init() 
	"""varcontainer is public class that I add for the convenience of 
	executing the constraints append codes in angr's internal module. 
	You can see part 3 for  more information.
	"""
	varcontainer.set_value("runcount",0) 
	"""the global flag "runcount" is used in simuvex/s_format.py,
	 value zero means it's the first run. value one means it's re-run. 
	"""
	print(varcontainer.get_value('runcount'))
	# read in base block trace
	trace_log = load_trace()
	'''print trace
	for i in range(len(trace_log)):
		print("%x" % trace_log[i])

	'''
	print("*************first run the binary and get constraints*************")
	#load binary	
	proj = angr.Project('demo1', load_options={'auto_load_libs': False})
	main = proj.loader.main_bin.get_symbol("main")
	#set entry point 
	state = proj.factory.blank_state(addr=main.addr)
	state.stack_push(0x0)
	p = proj.factory.path(state)
	print("start entry:0x%x" % proj.entry)
	print("main entry:0x%x" % main.addr)
	#print("0x%x" % p.addr)
	#match the binary entry with PIN's base block trace
	if p.addr != trace_log[0] :
		print("ERROR: Entrance is not matching, exit")
		exit
	#symbolic execte the path
	for i in range(1,len(trace_log)):
		pg=p.step() 		#execute one step(one baseblock),and get pathgroup 	
		print(len(pg[0].state.se.constraints))
		sg=p.successors 	#get the state group
		ins_addr=trace_log[i] 	#read one of PIN's trace 
		sucs_num=len(sg)      	#get the lenth of state group
		print("The path has", sucs_num, "successors!")
		print(pg)             	#print the path group
		if ins_addr == 0 :	#skip the lib function
			p=pg[0]		
			pg=p.step()
			
			p=pg[0]	
			print(len(p.state.se.constraints))
			continue
		else:			#choose and step into the match path
			for j in range(sucs_num):
				sucs_entry=sg[j].addr
				if sucs_entry == ins_addr :
					print("success entry[%d]:%x" % (1,sucs_entry))
					p=pg[j]	
					
					break
	#p=p.step()[0]

	#print path
	for step in p.trace:
		print(step)
	print('There are %d constraints.' % len(p.state.se.constraints))
	print("input numbers:%d" % len(p.state.posix.dumps(0)))
	print(p.state.posix.dumps(0))
	#print(p.state.se.constraints[8])


	# save constraints objects
	filename= 'constraint.out'
	with open(filename, 'w') as f:                              # open file with write-mode
	    picklestring = pickle.dump(p.state.se.constraints, f)   # serialize and save object


if __name__ == "__main__":
	main()

  ```
### Results
<img src="https://github.com/njuwangzhilong/angr/blob/master/CodeExamples/photo/firstrun.PNG" width = "800" height = "150" alt="first run" />   

## 2.Re-run binary  

  ```python 
  from __future__ import print_function

import struct

import angr
import logging
import logging
import pickle
from angr.globals import varcontainer
logging.getLogger('angr').setLevel('DEBUG')

def main():
	#init global vars 
	varcontainer._init()  
	varcontainer.set_value("runcount",1)
	print(varcontainer.get_value('runcount'))

	# read constraints objects
	filename= 'constraint.out'
	with open(filename, 'r') as f:
		# read constraints file and build constraints object
		constraints = pickle.load(f)   
		
		
		#re-run  
		print("***********************re-run the binary**************************")
		varcontainer.set_value("constraints",constraints) 
		varcontainer.set_value("runcount",1)
		#load binary	
		proj = angr.Project('demo1', load_options={'auto_load_libs': False})
		main = proj.loader.main_bin.get_symbol("main")
		#set entry point 
		state = proj.factory.blank_state(addr=main.addr)
		state.stack_push(0x00)
		p = proj.factory.path(state)
		print("start entry:0x%x" % proj.entry)
		print("main entry:0x%x" % main.addr)
		#symbolic execte the path
		while(True):
			
			pg=p.step() 		#execute one step(one baseblock),and get pathgroup 	
			print(len(pg[0].state.se.constraints))
			sg=p.successors 	#get the group of satisfied successor
			sucs_num=len(sg)      	#get the length of state group
			print("The path has", sucs_num, "successors!")
			print(pg)             	#print the path group
			if sg[0].addr==0x00 : Â  #As you can above, when set entry point, I push 0x00 into stack, a return to address 0x00  means that execution exits the main()'s stack frame. We will terminal the symbolic execution.
				break;
			for j in range(sucs_num):   #this will loop once.
				sucs_entry=sg[j].addr
				print("success entry[%d]:%x" % (1,sucs_entry))
				p=pg[j]	 #get the first successor.
				break    #in toy program, every branch only has one satisfied successor, so we just break in the first loop

		#print the execute trace
		for step in p.trace:
			print(step)
		print('There are %d constraints.' % len(p.state.se.constraints))
		print("input numbers:%d" % len(p.state.posix.dumps(0)))
		print(p.state.posix.dumps(0))

if __name__ == "__main__":
	main()
  ```   

### Results   
  <img src="https://github.com/njuwangzhilong/angr/blob/master/CodeExamples/photo/rerun.PNG" width = "800" height = "150" alt="rerun run" />


## 3.Class varcontainer    
&nbsp;&nbsp;&nbsp;&nbsp;Varcontainer is public class that I add for the convenience of executing the constraints append codes in angr's internal module. 
  ```python   
def _init():
    global _global_dict
    _global_dict = {}


def set_value(key,value):
    _global_dict[key] = value


def get_value(key,defValue=None):
    try:
        return _global_dict[key]
    except KeyError:
        return defValue
  ```   
## 4.Modification of method interpret in class FormatString    
&nbsp;&nbsp;&nbsp;&nbsp;Method interpret is used to interpret the format string of scanf() and add new symbolic variables according to parameter type. We add some codes to add constraints.
  ```python   
def interpret(self, addr, startpos, args, region=None):
        """
        Interpret a format string, reading the data at `addr` in `region` into `args` starting at `startpos`.
        """

        # TODO: we only support one format specifier in interpretation for now
        #filter the item in self.components with condition: isinstance(x,FormatSpecifier)
        format_specifier_count = len(filter(lambda x: isinstance(x, FormatSpecifier), self.components))
        if format_specifier_count > 1:
            l.warning("We don't support more than one format specifiers in format strings.")

        if region is None:
            region = self.parser.state.memory

        bits = self.parser.state.arch.bits
        failed = self.parser.state.se.BVV(0, bits)
        argpos = startpos 
        position = addr
        #print("Debug: in simuvex/engines/engine.py.process constraints_len %d" % len(self.parser.state.se.constraints))
        for component in self.components:
            if isinstance(component, str):
                # TODO we skip non-format-specifiers in format string interpretation for now
                # if the region doesn't match the concrete component, we need to return immediately
                pass
            else:
                print(component)
                fmt_spec = component
                try:
                    dest = args(argpos)
                except SimProcedureArgumentError:
                    dest = None
                if fmt_spec.spec_type == 's': #If the input of scanf() is string.
                    # set some limits for the find

                    max_str_len = self.parser.state.libc.max_str_len
                    max_sym_bytes = self.parser.state.libc.buf_symbolic_bytes

                    # has the length of the format been limited by the string itself?
                    if fmt_spec.length_spec is not None:
                        max_str_len = fmt_spec.length_spec
                        max_sym_bytes = fmt_spec.length_spec

                    # TODO: look for limits on other characters which scanf is sensitive to, '\x00', '\x20'
                    ohr, ohc, ohi = region.find(position, self.parser.state.se.BVV('\n'), max_str_len, max_symbolic_bytes=max_sym_bytes)

                    # if no newline is found, mm is position + max_strlen
                    # If-branch will really only happen for format specifiers with a length
                    mm = self.parser.state.se.If(ohr == 0, position + max_str_len, ohr)
                    # we're just going to concretize the length, load will do this anyways
                    length = self.parser.state.se.max_int(mm - position)
                    src_str = region.load(position, length)
                    print(self.parser.state.se.constraints)
                    print(src_str)
                    self.parser.state.memory.store(dest, src_str)
                    # TODO all of these should be delimiters we search for above
                    # add that the contents of the string cannot be any scanf %s string delimiters
                    for delimiter in set(FormatString.SCANF_DELIMITERS) - {'\x00'}:
                        delim_bvv = self.parser.state.se.BVV(delimiter)
                        for i in range(length):
                            self.parser.state.add_constraints(region.load(position + i, 1) != delim_bvv)

                    # write it out to the pointer
                    # store the terminating null byte
                    self.parser.state.memory.store(dest + length, self.parser.state.se.BVV(0, 8))
                    # did by wangzhilong for replay
# Attention Attention Attention. This is the code I add to append constraints in after string input.
                    if(varcontainer.get_value('runcount')==1):
                        for constraint in varcontainer.get_value('constraints'):
                            self.parser.state.add_constraints(constraint)
# Attention Attention Attention. End of added codes.

                    position += length

                else:

                    # XXX: atoi only supports strings of one byte
                    if fmt_spec.spec_type in ['d', 'u', 'x']:

                        base = 16 if fmt_spec.spec_type == 'x' else 10
                        
                        status, i, num_bytes = self.parser._sim_atoi_inner(position, region, base=base, read_length=fmt_spec.length_spec)
                        # increase failed count if we were unable to parse it
                        
                        failed = self.parser.state.se.If(status, failed, failed + 1)
                        position += num_bytes
                    elif fmt_spec.spec_type == 'c':
                        i = region.load(position, 1)
                        i = i.zero_extend(bits - 8)
                        position += 1
                    else:
                        raise SimProcedureError("unsupported format spec '%s' in interpret" % fmt_spec.spec_type)
                    
                    i = self.parser.state.se.Extract(fmt_spec.size*8-1, 0, i)

                    self.parser.state.memory.store(dest, i, size=fmt_spec.size, endness=self.parser.state.arch.memory_endness)
                argpos += 1
        # we return (new position, number of items parsed)
        # new position is used for interpreting from a file, so we can increase file position
        return (position, ((argpos - startpos) - failed))
  ``` 

## For more information.   
&nbsp;&nbsp;&nbsp;&nbsp;Ref: [How angr step() into simulative scanf()](https://github.com/njuwangzhilong/angr/blob/master/glibc_fun_simu.MD)
