"""
In this challenge we're given a text file with trace of a program execution. The file has two columns, address and instruction executed. So we know all the instructions being executed, and which branches were taken. But the initial data is not known.
we symbolicly execute the traced path, and get the constraint of input.
"""
#print("0x%x" % s.addr_trace[-1])
from __future__ import print_function

import struct

import angr

'''
this function read the trace generated by pin
'''
def load_trace():
	res = []
	with open("CodeExamples/trace.out") as f:
		for line in f:
			if line.startswith('[B_ENT]'):
				addr = int(line[7:7+6], 16)
				res.append(addr)
			elif line.startswith('[C2LIB]') :
				addr = int(0)
				res.append(addr)

	return res
def main():
	# read in base block trace
	trace_log = load_trace()
	'''print trace
	for i in range(len(trace_log)):
		print("%x" % trace_log[i])

	'''
	#load binary	
	proj = angr.Project('CodeExamples/test', load_options={'auto_load_libs': False})
	main = proj.loader.main_bin.get_symbol("main")
	#set entry point 
	state = proj.factory.blank_state(addr=main.addr)
	state.stack_push(0x0)
	p = proj.factory.path(state)
	print("start entry:0x%x" % proj.entry)
	print("main entry:0x%x" % main.addr)
	#print("0x%x" % p.addr)
	#match the binary entry with PIN's base block trace
	if p.addr != trace_log[0] :
		print("ERROR: Entrance is not matching, exit")
		exit
	#symbolic execte the path
	for i in range(1,len(trace_log)):
		pg=p.step() 		#execute one step(one baseblock),and get pathgroup 
		sg=p.successors 	#get the state group
		ins_addr=trace_log[i] 	#read one of PIN's trace 
		sucs_num=len(sg)      	#get the lenth of state group
		print("The path has", sucs_num, "successors!")
		print(pg)             	#print the path group
		if ins_addr == 0 :	#skip the lib function
			p=pg[0]		
			pg=p.step()
			p=pg[0]	
			continue
		else:			#choose and step into the match path
			for j in range(sucs_num):
				sucs_entry=sg[j].addr
				if sucs_entry == ins_addr :
					print("success entry[%d]:%x" % (1,sucs_entry))
					p=pg[j]	
					break
	'''
	p=p.step()[0]
	for k in range(len(p.addr_trace.hardcopy)):
		print("0x%x" % p.addr_trace.hardcopy[k])
	'''
	for step in p.trace:
		print(step)
	print(p.state.posix.dumps(0)) #this can give you concret input values
	print(p.state.se.constraints) #this can give you the input constraints
	return


if __name__ == "__main__":
	main()
